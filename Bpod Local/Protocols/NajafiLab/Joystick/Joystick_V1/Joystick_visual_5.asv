function Joystick_visual

global BpodSystem
global S
global M
global LastKnownEncPos

%% Import scriptsBpod

m_Plotter = Plotter;
m_InitGUI = InitGUI;
m_TrialConfig = TrialConfig;


%% Turn off Bpod LEDs

% This code will disable the state machine status LED
BpodSystem.setStatusLED(0);

%% Assert HiFi module is present + USB-paired (via USB button on console GUI)

BpodSystem.assertModule('HiFi', 1); % The second argument (1) indicates that the HiFi module must be paired with its USB serial port
% Create an instance of the HiFi module
H = BpodHiFi(BpodSystem.ModuleUSB.HiFi1); % The argument is the name of the HiFi module's USB serial port (e.g. COM3)

%% Connect Maestro
M = PololuMaestro('COM15');

%% Assert Stepper + Rotary Encoder modules are present + USB-paired (via USB button on console GUI)
BpodSystem.assertModule({'Stepper','RotaryEncoder'}, [1 1]); % The second argument [1 1] indicates that both HiFi and RotaryEncoder must be paired with their respective USB serial ports
BpodSystem.PluginObjects.S = BpodStepperModule(BpodSystem.ModuleUSB.Stepper1);
BpodSystem.PluginObjects.R = RotaryEncoderModule(BpodSystem.ModuleUSB.RotaryEncoder1); 


%% Define parameters

[S] = m_InitGUI.SetParams(BpodSystem);





%% Define trials

% set max number of trials
MaxTrials = 1000;

% initialize anti-bias variables
AntiBiasVar.IncorrectFlag = 0;
AntiBiasVar.IncorrectType = 1;
AntiBiasVar.CompletedHist.left = [];
AntiBiasVar.CompletedHist.right = [];
AntiBiasVar.ValveFlag = 0;

% get uniform distribution of 2 trial types
TrialTypes = ceil(rand(1,MaxTrials)*2); 

% adjust warmup trials to have no more than 'max' number of consecutive
% same-side trials
[TrialTypes] = m_TrialConfig.AdjustWarmupTrials(S, TrialTypes);
   
BpodSystem.Data.TrialTypes = []; % The trial type of each trial completed will be added here.



%% Initialize plots

% Side Outcome Plot
BpodSystem.ProtocolFigures.SideOutcomePlotFig = figure('Position', [50 540 1000 220],'name','Outcome plot','numbertitle','off', 'MenuBar', 'none', 'Resize', 'off');
BpodSystem.GUIHandles.OutcomePlot = axes('Position', [.075 .35 .89 .55]);
SideOutcomePlot(BpodSystem.GUIHandles.OutcomePlot,'init',2-TrialTypes);
BpodParameterGUI('init', S); % Initialize parameter GUI plugin

BpodSystem.GUIHandles.TTOP_Ylabel = 'Press'

%-- Last Trial encoder plot (an online plot included in the protocol folder)
BpodSystem.ProtocolFigures.EncoderPlotFig = figure('Position', [500 200 1500 600],'name','Encoder plot','numbertitle','off', 'MenuBar', 'none', 'Resize', 'off');
BpodSystem.GUIHandles.EncoderAxes = axes('Position', [.15 .15 .8 .8]);
LastTrialEncoderPlot(BpodSystem.GUIHandles.EncoderAxes, 'init', S.GUI.Threshold);
%LastTrialEncoderPlot(BpodSystem.GUIHandles.EncoderAxes, 'init', 6);

useStateTiming = true;  % Initialize state timing plot
if ~verLessThan('matlab','9.5') % StateTiming plot requires MATLAB r2018b or newer
    useStateTiming = true;
    StateTiming();
end

%% Setup stepper module
BpodSystem.PluginObjects.S.holdRMScurrent = 0; % set 'zero' initial lever

if 0
    BpodSystem.PluginObjects.S.MaxSpeed = 1000; % set max speed
    BpodSystem.PluginObjects.S.Acceleration = 1; % set acceleration
    BpodSystem.PluginObjects.S.RMScurrent = 1; % set RMS current
    BpodSystem.PluginObjects.S.holdRMScurrent = 30; % set initial lowest nonzero resistance
end

%% Setup rotary encoder module


%BpodSystem.PluginObjects.S.holdRMScurrent = 900; % find nearest detent and hold, use as zero pos
M.setMotor(0, ConvertMaestroPos(S.GUI.ServoInPos));
pause(0.5); % pause for servo to move to in pos
BpodSystem.PluginObjects.R.setPosition(0); % Set the current position to equal 0
LastKnownEncPos = 0; % last known location of encoder pos
BpodSystem.PluginObjects.R.thresholds = S.GUI.Threshold;
BpodSystem.PluginObjects.R.sendThresholdEvents = 'on'; % If on, rotary encoder module will send threshold events to state machine
BpodSystem.PluginObjects.R.startUSBStream;
BpodSystem.SoftCodeHandlerFunction = 'SoftCodeHandler_Joystick';

%% Define stimuli and send to analog module

%SF = 192000; % Use max supported sampling rate samples/sec
SF = 44100; % Use lower sampling rate (samples/sec) to allow for longer duration audio file (max length limited by HiFi)
H.SamplingRate = SF;
Envelope = 1/(SF*0.001):1/(SF*0.001):1; % Define 1ms linear ramp envelope of amplitude coefficients, to apply at sound onset + in reverse at sound offset

InitCueSound = GenerateSineWave(SF, S.GUI.InitCueFreq_Hz, S.GUI.InitCueDuration_s)*S.GUI.InitCueVolume_percent; % Sampling freq (hz), Sine frequency (hz), duration (s)
InitCueSound = ApplySoundEnvelope(InitCueSound, Envelope);

GoCueSound = GenerateSineWave(SF, S.GUI.GoCueFreq_Hz, S.GUI.GoCueDuration_s)*S.GUI.GoCueVolume_percent; % Sampling freq (hz), Sine frequency (hz), duration (s)
GoCueSound = ApplySoundEnvelope(GoCueSound, Envelope);

IncorrectSound = GenerateWhiteNoise(SF, S.GUI.PunishSoundDuration_s, 1, 1)*S.GUI.IncorrectSoundVolume_percent; % white noise punish sound
IncorrectSound = ApplySoundEnvelope(IncorrectSound, Envelope);

% generate audio stim same duration as vis gratings

AudioStimSound = GenerateSineWave(SF, S.GUI.AudioStimFreq_Hz, S.GUI.GratingDur_s)*S.GUI.AudioStimVolume_percent; % Sampling freq (hz), Sine frequency (hz), duration (s)
AudioStimSound = ApplySoundEnvelope(AudioStimSound, Envelope);

H.DigitalAttenuation_dB = -25; % Set a comfortable listening level for most headphones (useful during protocol dev).
H.load(1, InitCueSound);
H.load(2, GoCueSound);
H.load(3, IncorrectSound);


% Remember values of sound frequencies & durations, so a new one only gets uploaded if it was changed
LastInitCueFrequency = S.GUI.InitCueFreq_Hz; 
LastGoCueFrequency = S.GUI.GoCueFreq_Hz;
LastAudioStimFrequency = S.GUI.AudioStimFreq_Hz;

LastInitCueDuration = S.GUI.InitCueDuration_s;
LastGoCueDuration = S.GUI.GoCueDuration_s;
LastPunishSoundDuration = S.GUI.PunishSoundDuration_s;

LastInitCueVolume = S.GUI.InitCueVolume_percent;
LastGoCueVolume = S.GUI.GoCueVolume_percent;
LastAudioStimVolume = S.GUI.AudioStimVolume_percent;
LastIncorrectSoundVolume = S.GUI.IncorrectSoundVolume_percent;


%% Setup video

if isfield(BpodSystem.PluginObjects, 'V') % Clear previous instances of the video server
    BpodSystem.PluginObjects.V = [];
end
MonitorID = 1;
BpodSystem.PluginObjects.V = PsychToolboxVideoPlayer(MonitorID, 0, [0 0], [180 180], 0); % Assumes second monitor is screen #2. Sync patch = 180x180 pixels

BpodSystem.PluginObjects.V.SyncPatchIntensity = 255; % increased, seems 140 doesn't always trigger BNC high

% Indicate loading
BpodSystem.PluginObjects.V.loadText(1, 'Loading...', '', 80);
BpodSystem.PluginObjects.V.play(1);

Ysize = BpodSystem.PluginObjects.V.ViewPortDimensions(2);
Xsize = BpodSystem.PluginObjects.V.ViewPortDimensions(1);

% compute grating according to square grid of largest pixel dimension
if Ysize > Xsize
    gratingSize = [Ysize, Ysize]; % Size of grating in pixels
else
    gratingSize = [Xsize, Xsize]; % Size of grating in pixels
end

spatialFreq = .005; % Spatial frequency of grating in cycles per pixel % .32
orientation = 0; % Orientation of grating in degrees
contrast = 1; % Contrast of grating (0 to 1)
phase = 0.5;

% Calculate the parameters needed for the grating
pixPerCycle = 1 / spatialFreq;
freqPerPixel = 1 / pixPerCycle;

[x, y] = meshgrid(1:gratingSize(1), 1:gratingSize(2));

gray = 0.5 * ones(gratingSize);
sinGrating = gray + contrast/2 .* sin(freqPerPixel * 2 * pi * (cos(orientation * pi / 180) * x + sin(orientation * pi / 180) * y) + phase);
sinGrating(sinGrating > 1) = 1; % Cap values above 1 to 1 (white)
sinGrating(sinGrating < 0) = 0; % Cap values below 0 to 0 (black)

gray = gray(1:Ysize, 1:Xsize); % clip to monitor
sinGrating = sinGrating(1:Ysize, 1:Xsize); % clip to monitor

% these images are 0 - 1 amplitude, fine for grating_flashes.m file but need to be 0 - 255 for
% building video this way
gray = gray * 255;
sinGrating = sinGrating * 255;

FramesPerSecond = BpodSystem.PluginObjects.V.DetectedFrameRate;

GratingDuration = S.GUI.GratingDur_s; % set duration of grating to stimulus interval
GrayFixedDuration = S.GUI.ISIOrig_s; % set duration of gray screen to inter stimulus interval

% need an integer number of frames, there is no fractional frame
% need an even number of frames for sync patch to alternate
GratingFrames = convergent(FramesPerSecond * GratingDuration);  % maybe use floor for this? then continue to round up below?
if (mod(GratingFrames, 2) ~= 0)
    GratingFrames = GratingFrames + 1; % round up to nearest even integer
end
GratingDuration = GratingFrames / FramesPerSecond; % convert even rounded number of frames back into duration to calculate video duration

GrayFixedFrames = convergent(FramesPerSecond * GrayFixedDuration);
if (mod(GrayFixedFrames, 2) ~= 0)
    GrayFixedFrames = GrayFixedFrames + 1; % round up to nearest even integer
end
GrayFixedDuration = GrayFixedFrames / FramesPerSecond; % convert even rounded number of frames back into duration to calculate video duration


VideoGrating = repmat(sinGrating, 1, 1, 2); % 2 frames to get sync signal encoded
VideoGrayFixed = repmat(gray, 1, 1, 2); % 2 frames to get sync signal encoded

BpodSystem.PluginObjects.V.loadVideo(1, VideoGrating);
BpodSystem.PluginObjects.V.loadVideo(2, VideoGrayFixed);

% compose grating video
GratingFrame_SyncW = BpodSystem.PluginObjects.V.Videos{1}.Data(1);
GratingFrame_SyncBlk = BpodSystem.PluginObjects.V.Videos{1}.Data(2);
GratingBlank = BpodSystem.PluginObjects.V.Videos{1}.Data(3);

GratingPattern = [GratingFrame_SyncW GratingFrame_SyncW];

GratingVideo = [repmat(GratingPattern, 1, GratingFrames/2)];

BpodSystem.PluginObjects.V.Videos{3} = struct;
BpodSystem.PluginObjects.V.Videos{3}.nFrames = GratingFrames + 1; % + 1 for final frame
BpodSystem.PluginObjects.V.Videos{3}.Data = [GratingVideo GratingBlank];

% compose gray video, fixed ISI
GrayFrame_SyncW = BpodSystem.PluginObjects.V.Videos{2}.Data(1);
GrayFrame_SyncBlk = BpodSystem.PluginObjects.V.Videos{2}.Data(2);
GrayBlank = BpodSystem.PluginObjects.V.Videos{2}.Data(3);

GrayPattern = [GrayFrame_SyncBlk GrayFrame_SyncBlk];

GrayVideo = [repmat(GrayPattern, 1, GrayFixedFrames/2)];

% update durations based on number of frames generated
GratingDur = length(GratingVideo) * (1/FramesPerSecond);
GrayDur = length(GrayVideo) * (1/FramesPerSecond);

BpodSystem.PluginObjects.V.Videos{4} = struct;
BpodSystem.PluginObjects.V.Videos{4}.nFrames = GrayFixedFrames + 1; % + 1 for final frame
BpodSystem.PluginObjects.V.Videos{4}.Data = [GrayVideo GrayBlank];

VideoPrePerturbPattern = [GratingVideo GrayVideo]; % base video pattern for initial segment repetitions of grating->gray

% try to get Frame2TTL BNC sync to be low and not miss first frame of vis
% stim later
GrayInitBNCSync = [repmat(GrayFrame_SyncW, 1, 120) GrayFrame_SyncBlk];
BpodSystem.PluginObjects.V.Videos{6} = struct;
BpodSystem.PluginObjects.V.Videos{6}.nFrames = 121; % + 1 for final frame
BpodSystem.PluginObjects.V.Videos{6}.Data = GrayInitBNCSync;

VideoData = [repmat(VideoPrePerturbPattern, 1, S.GUI.NumISIOrigRep) GratingVideo]; % add one more grating video after initial repetitions

PrePerturbDur = (GratingDuration + GrayFixedDuration) * S.GUI.NumISIOrigRep + GratingDuration;

LastGratingDuration = S.GUI.GratingDur_s; % Remember value of stim dur so that we only regenerate the grating video if parameter has changed
LastGrayFixedDuration = S.GUI.ISIOrig_s; % Remember value of pre-perturb gray dur so that we only regenerate the pre-perturb gray video if parameter has changed
LastNumISIOrigRep = S.GUI.NumISIOrigRep;  % Remember value of initial segment repetitions so that we only regenerate the initial segment if parameter changed

BpodSystem.PluginObjects.V.TimerMode = 0;
pause(1.0); % matlab seems to require a pause here before clearing screen with play(0), 
            % otherwise can get stuck on Psychtoolbox splash screen
            % might need longer delay if purple image hangs on window open
BpodSystem.PluginObjects.V.play(0);
%BpodSystem.SoftCodeHandlerFunction = 'SoftCodeHandler_PlayVideo';

BpodSystem.PluginObjects.V.play(6);
BpodSystem.PluginObjects.V.TimerMode = 2;
% wait for parameter update and confirm before beginning trial loop
input('Set parameters and press enter to continue >', 's'); 
S = BpodParameterGUI('sync', S);


%% check difficulty options and ensure correct setting prior to beginning first trial

% define discrete values in distribution
DifficultyLevels = [1, 2, 3, 4];  % 1 - Easy, 2 - MediumEasy, 3 - MediumHard, 4 - Hard

WarmupTrialsCounter = S.GUI.NumEasyWarmupTrials;
LastNumEasyWarmupTrials = S.GUI.NumEasyWarmupTrials; % store GUI value to determine if user has changed this param to reset counter


%% 
LastWaitDurOrig_s = S.GUI.WaitDurOrig_s;
LastWaitDurStep_s = S.GUI.WaitDurStep_s;
% init wait dur
wait_dur = 0;

%% Main trial loop

for currentTrial = 1:MaxTrials
   
    ExperimenterTrialInfo.TrialNumber = currentTrial;   % capture variable states as field/value struct for experimenter info

    %% sync trial-specific parameters from GUI
    S.GUI.currentTrial = currentTrial; % This is pushed out to the GUI in the next line
    S = BpodParameterGUI('sync', S); % Sync parameters with BpodParameterGUI plugin    


    %% anti bias

    [TrialTypes] = m_TrialConfig.ManuallFraction( ...
        S, currentTrial, TrialTypes);

    % [TrialTypes, AntiBiasVar] = m_TrialConfig.RepeatedIncorrect( ...
    %     BpodSystem, S, AntiBiasVar, currentTrial, TrialTypes);
    % [TrialTypes, AntiBiasVar] = [;

    % [AntiBiasVar, LeftValveTime, RightValveTime, TrialTypes] = m_TrialConfig.AntiBiasValveAdjust( ...
    %     BpodSystem, S, AntiBiasVar, currentTrial, TrialTypes);
    LeftValveTime = 0;
    RightValveTime = 0;

    %% update trial-specific valve times according to set reward amount

    CenterValveTime = S.GUI.CenterValveTime_s;
    ExperimenterTrialInfo.LeftValveTime = LeftValveTime;
    ExperimenterTrialInfo.RightValveTime = RightValveTime;


    %% set state matrix vars according to contigency

    switch TrialTypes(currentTrial) % Determine trial-specific state matrix fields
        case 1 % left side is rewarded
            CorrectLick = 'Port1In';
            CorrectPort = 'Port1';
            IncorrectLick = 'Port3In';
            IncorrectPort = 'Port3';
            ValveTime = LeftValveTime; 
            Valve = 'Valve1';
        case 2  % right side is rewarded 
            CorrectLick = 'Port3In';
            CorrectPort = 'Port3';
            IncorrectLick = 'Port1In';
            IncorrectPort = 'Port1';
            ValveTime = RightValveTime; 
            Valve = 'Valve3';
    end


    %% get difficulty level for this trial
    
    % check if user has changed number of warmup trials    
    if S.GUI.NumEasyWarmupTrials ~= LastNumEasyWarmupTrials
        WarmupTrialsCounter = S.GUI.NumEasyWarmupTrials;    % update warmap trial counter to current gui param
        LastNumEasyWarmupTrials = S.GUI.NumEasyWarmupTrials;    % store currenct value to check for change again
    end

    % if warmup trial, choose easy, otherwise pick difficulty from
    % weighted probability distribution    
    if WarmupTrialsCounter > 0
        ExperimenterTrialInfo.Warmup = true;   % capture variable states as field/value struct for experimenter info
        ExperimenterTrialInfo.WarmupTrialsRemaining = WarmupTrialsCounter;   % capture variable states as field/value struct for experimenter info

        TrialDifficulty = 1;  % set warmup trial to easy     
    else 

        PercentTrialsEasy = S.GUI.PercentTrialsEasy;
        PercentTrialsMediumEasy = S.GUI.PercentTrialsMediumEasy;
        PercentTrialsMediumHard = S.GUI.PercentTrialsMediumHard;
        PercentTrialsHard = S.GUI.PercentTrialsHard;

        sum = PercentTrialsEasy + PercentTrialsMediumEasy + PercentTrialsMediumHard + PercentTrialsHard;

        FractionEasy = PercentTrialsEasy / sum;
        FractionMediumEasy = PercentTrialsMediumEasy / sum;
        FractionMediumHard = PercentTrialsMediumHard / sum;
        FractionHard = PercentTrialsHard / sum;
        
        % assigned probability weights for sampling from distribution
        %DifficultyProbabilities = [FractionEasy, FractionMedium, FractionHard];
        DifficultyProbabilities = [FractionEasy, FractionMediumEasy, FractionMediumHard, FractionHard];
        

        % if we've reached here, then the weights sum to a probability of 1.0,
        % now draw random sample according to probability weights
        cp = [0, cumsum(DifficultyProbabilities)]; % cumulative probability -> use as interval to pick Easy OR Medium OR Hard (one occurs every draw)
        r = rand; % get random scalar drawn from the uniform distribution in the interval (0,1).
        ind = find(r>cp, 1, 'last');  % get discrete index (1, 2, or 3 for Easy, Medium, or Hard in this case)
        TrialDifficulty = DifficultyLevels(ind); % get discrete value at the randomly (according to probability weights) selected index,
                                        % in this case of 1 = Easy, 2 = Medium, 3 = Hard it will be the same as the index.  
                                        % This step is here in case more or fewer difficulty levels are added in the future, 
                                        % this gets used as example for drawing from weighted distribution later, or any other unforseen reason
        
        ExperimenterTrialInfo.Warmup = false;   % capture variable states as field/value struct for experimenter info
        ExperimenterTrialInfo.WarmupTrialsRemaining = 0;   % capture variable states as field/value struct for experimenter info
    end    

    switch TrialDifficulty
        case 1
            ExperimenterTrialInfo.Difficulty = 'Easy';   % capture variable states as field/value struct for experimenter info
        case 2
            ExperimenterTrialInfo.Difficulty = 'Medium-Easy';   % capture variable states as field/value struct for experimenter info
        case 3
            ExperimenterTrialInfo.Difficulty = 'Medium-Hard';   % capture variable states as field/value struct for experimenter info
        case 4
            ExperimenterTrialInfo.Difficulty = 'Hard';   % capture variable states as field/value struct for experimenter info
    end

    %% Draw trial-specific and difficulty-defined TimeOutPunish from exponential distribution

    [TimeOutPunish] = m_TrialConfig.GetTimeOutPunish(S);

    ExperimenterTrialInfo.TimeOutPunish = TimeOutPunish;


    %% Draw trial-specific ITI from exponential distribution

    [ITI] = m_TrialConfig.GetITI(S);

    ExperimenterTrialInfo.ITI = ITI;


    %% construct preperturb vis stim videos and audio stim base for grating and gray if duration parameters changed
    
    if S.GUI.GratingDur_s ~= LastGratingDuration
        GratingDuration = S.GUI.GratingDur_s; % set duration of grating to stimulus interval        
          
        % need an integer number of frames, there is no fractional frame
        % need an even number of frames for sync patch to alternate
        GratingFrames = convergent(FramesPerSecond * GratingDuration);  % maybe use floor for this? then continue to round up below?
        if (mod(GratingFrames, 2) ~= 0)
            GratingFrames = GratingFrames + 1; % round up to nearest even integer
        end
        % GratingDuration = GratingFrames / FramesPerSecond; % convert even rounded number of frames back into duration to calculate video duration

        % compose grating video
        GratingVideo = [repmat(GratingPattern, 1, GratingFrames/2)];
        
        % update durations based on number of frames generated
        GratingDur = length(GratingVideo) * (1/FramesPerSecond);
    end
    if S.GUI.ISIOrig_s ~= LastGrayFixedDuration
        GrayFixedDuration = S.GUI.ISIOrig_s; % set duration of gray screen to inter stimulus interval

        GrayFixedFrames = convergent(FramesPerSecond * GrayFixedDuration);
        if (mod(GrayFixedFrames, 2) ~= 0)
            GrayFixedFrames = GrayFixedFrames + 1; % round up to nearest even integer
        end
       
        % compose gray video, fixed ISI
        GrayVideo = [repmat(GrayPattern, 1, GrayFixedFrames/2)];
               
        % update durations based on number of frames generated
        GrayDur = length(GrayVideo) * (1/FramesPerSecond);        
    end


    %% update video& audio and change tracking variables for audio and vis stim

    % if vis stim dur, audio stim freq, or volume changed then update sound wave
    if (S.GUI.GratingDur_s ~= LastGratingDuration) || ...
        (S.GUI.AudioStimFreq_Hz ~= LastAudioStimFrequency) || ...
        (S.GUI.AudioStimVolume_percent ~= LastAudioStimVolume)
        % generate audio stim of 15s (longer than vis stim to go cue would
        % be) then turn sound off at beginning of next state after vis stim
        AudioStimSound = GenerateSineWave(SF, S.GUI.AudioStimFreq_Hz, GratingDur)*S.GUI.AudioStimVolume_percent; % Sampling freq (hz), Sine frequency (hz), duration (s) 
        AudioStimSound = ApplySoundEnvelope(AudioStimSound, Envelope);

        LastAudioStimFrequency = S.GUI.AudioStimFreq_Hz;
        LastAudioStimVolume = S.GUI.AudioStimVolume_percent;
    end
    % if stim or isi dur changed, initial video pattern has to be
    % reconstructed from parts above
    if (S.GUI.GratingDur_s ~= LastGratingDuration) || (S.GUI.ISIOrig_s ~= LastGrayFixedDuration) || (S.GUI.NumISIOrigRep ~= LastNumISIOrigRep)
        VideoPrePerturbPattern = [GratingVideo GrayVideo]; % base video pattern for initial segment repetitions of grating->gray
        VideoData = [repmat(VideoPrePerturbPattern, 1, S.GUI.NumISIOrigRep) GratingVideo]; % construct initial video segment, add one more grating video after initial repetitions
        LastGratingDuration = S.GUI.GratingDur_s; % Remember value of stim dur so that we only regenerate the grating video if parameter has changed
        LastGrayFixedDuration = S.GUI.ISIOrig_s; % Remember value of stim dur so that we only regenerate the grating video if parameter has changed
        LastNumISIOrigRep = S.GUI.NumISIOrigRep;  % Remember value of initial segment repetitions so that we only regenerate the initial segment if parameter changed
    end
       

    %% set vis stim perturbation ISI duration according to trial-specific difficulty level
    % draw perturbation interval from uniform distribution in range according to difficulty

    EasyMinPercent = 3/4;
    EasyMaxPercent = 1;
    MediumEasyMinPercent = 1/2;
    MediumEasyMaxPercent = 3/4;
    MediumHardMinPercent = 1/4;
    MediumHardMaxPercent = 1/2;
    HardMinPercent = 0;
    HardMaxPercent = 1/4;
   
    % calculate category boundary to use as base timing reference for
    % perturbation length
    CatBound = S.GUI.ISIOrig_s;   % updated category boundary to be ISI_perturb * 1.5

    ExperimenterTrialInfo.CategoryBoundary = CatBound;   % capture variable states as field/value struct for experimenter info

    % full range of perturbation is calculated as the category boundary time
    % minus the selected minimum time separation from the category boundary and the grating

    PerturbDurFullRange = CatBound * 1000 - S.GUI.MinISIPerturb_ms; 
                                                                                                     
    switch TrialDifficulty % Determine trial-specific visual stimulus
        case 1
            PerturbDurMin = EasyMinPercent*PerturbDurFullRange;
            PerturbDurMax = EasyMaxPercent*PerturbDurFullRange;
        case 2
            PerturbDurMin = MediumEasyMinPercent*PerturbDurFullRange;
            PerturbDurMax = MediumEasyMaxPercent*PerturbDurFullRange;

        case 3
            PerturbDurMin = MediumHardMinPercent*PerturbDurFullRange;
            PerturbDurMax = MediumHardMaxPercent*PerturbDurFullRange;            
        
        case 4
            PerturbDurMin = HardMinPercent*PerturbDurFullRange;
            PerturbDurMax = HardMaxPercent*PerturbDurFullRange;
    end

    % after applying difficulty to perturbation range, shift the min and
    % max away to the selected minimum from category boundary
    % PerturbDurMin = PerturbDurMin + S.GUI.PerturbMinFromCB_ms;
    % PerturbDurMax = PerturbDurMax + S.GUI.PerturbMinFromCB_ms;

    debugDiffRanges = 1;
    if debugDiffRanges
        EasyMin = (EasyMinPercent*PerturbDurFullRange)/1000;
        EasyMax = (EasyMaxPercent*PerturbDurFullRange)/1000;
        MediumEasyMin = (MediumEasyMinPercent*PerturbDurFullRange)/1000;
        MediumEasyMax = (MediumEasyMaxPercent*PerturbDurFullRange)/1000;
        MediumHardMin = (MediumHardMinPercent*PerturbDurFullRange)/1000;
        MediumHardMax = (MediumHardMaxPercent*PerturbDurFullRange)/1000;        
        HardMin = (HardMinPercent*PerturbDurFullRange)/1000;
        HardMax = (HardMaxPercent*PerturbDurFullRange)/1000;
    end
    
    % EasyMax activation.
    % default: naive/mid1 is activated. mid2/well is deactivated.
    [RandomPerturbationDur, EasyMaxInfo] = m_TrialConfig.GetPerturbationDur( ...
        S, EasyMax, PerturbDurMin, PerturbDurMax);
    ExperimenterTrialInfo.EasyMax = EasyMaxInfo;

    % record trial unadjusted ISI random dur 
    BpodSystem.Data.TrialVars.Trial{currentTrial}.RandomPerturbationDur = RandomPerturbationDur;

    ExperimenterTrialInfo.DistanceFromCategoryBoundary = RandomPerturbationDur;   % capture variable states as field/value struct for experimenter info

    % set short and long ISI according to contingency defined by gui params
    % maybe collapse this into smaller if conditions
    switch TrialTypes(currentTrial) % Determine trial-specific visual stimulus duration
        case 1 % trial is left with short ISI                    
            GrayPerturbDuration = CatBound - RandomPerturbationDur; % for left reward, ISI is subtractd from the random duration            
        case 2 % trial is right with long ISI                    
            GrayPerturbDuration = CatBound + RandomPerturbationDur; % for right reward, ISI is added to the random duration
    end
    
    m_Plotter.UpdateOutcomePlot(BpodSystem, TrialTypes, 0); % this will update the SideOutcomePlot to reflect the current trial type after accounting for any change due to anti-bias control 
  
    debugGrayPerturbDuration = GrayPerturbDuration;


    %% Construct trial-specific portion of video and add it to base video

    % construct video for this trial
    
    % find number of frames for variable ISI    
    GrayPerturbFrames = convergent(FramesPerSecond * GrayPerturbDuration); % rounds ties to the nearest even integer

    if (mod(GrayPerturbFrames, 2) ~= 0)
        GrayPerturbFrames = GrayPerturbFrames + 1; % round up to nearest even integer
    end
    GrayPerturbVideo = [repmat(GrayPattern, 1, GrayPerturbFrames/2)];

    GrayPerturbDuration = GrayPerturbFrames / FramesPerSecond; % convert even rounded number of frames back into duration to calculate video duration

    ExperimenterTrialInfo.ISIPerturbDuration = GrayPerturbDuration;   % capture variable states as field/value struct for experimenter info

    VideoPerturbBasePattern = [GrayPerturbVideo GratingVideo]; % perturbation video pattern for second segment repetitions of random ISI gray->grating

    % find the nearest whole number duration of perturbation gray->grating that fits
    % within the scaled duration of the pre-preturbation segment
    PerturbBasePatternDuration = GrayPerturbDuration + GratingDuration;
    ScaledPrePerturbDuration = ((length(VideoData)-GratingFrames) / FramesPerSecond) * S.GUI.PostPerturbDurMultiplier;
    NumPerturbVisRep = floor(ScaledPrePerturbDuration/PerturbBasePatternDuration);
   
    %NumPerturbVisRep_frame_remainder = floor((ScaledPrePerturbDuration/PerturbBasePatternDuration - fix(ScaledPrePerturbDuration/PerturbBasePatternDuration))*FramesPerSecond);
    NumPerturbVisRep_frame_remainder = floor((ScaledPrePerturbDuration/PerturbBasePatternDuration - fix(ScaledPrePerturbDuration/PerturbBasePatternDuration))* length(VideoPerturbBasePattern));
    if NumPerturbVisRep_frame_remainder > 0
        VideoPerturbBasePattern_remaining_frames = VideoPerturbBasePattern(1:NumPerturbVisRep_frame_remainder);
    else
        VideoPerturbBasePattern_remaining_frames = [];
    end

    % use extra perturbation video for naive to extend vis stim to ITI
    switch S.GUI.TrainingLevel
        case 1 % Habituation       
            NumExtraPerturbVisRep = 90;   
        case 2 % Naive       
            NumExtraPerturbVisRep = 90;        
        case 3 % Mid Trained 1
            NumExtraPerturbVisRep = 90;
        case 4 % Mid Trained 2
            NumExtraPerturbVisRep = 90;
        case 5 % Trained
            NumExtraPerturbVisRep = 0;
    end

    NumInitialBaseFrames = GratingFrames + GrayFixedFrames;
    NumPerturbBaseFrames = GrayPerturbFrames + GratingFrames;

    NumPerturbReps = NumPerturbVisRep + NumExtraPerturbVisRep;

    TotalFramesNeeded = (S.GUI.NumISIOrigRep * NumInitialBaseFrames) + ...
        (S.GUI.NumISIOrigRep * NumInitialBaseFrames) * S.GUI.PostPerturbDurMultiplier + ...
        GratingFrames; % number of frames needed is     
    GrayFillerFramesNeeded = TotalFramesNeeded - (length(VideoData) + (length(VideoPerturbBasePattern)*NumPerturbReps));
    
    GrayFillerFramesNeeded = round(GrayFillerFramesNeeded); % get integer number of frames
    if (mod(GrayFillerFramesNeeded, 2) ~= 0)
        GrayFillerFramesNeeded = GrayFillerFramesNeeded + 1; % round up to nearest even integer
    end

    VideoGrayFiller = [repmat(GrayPattern, 1, GrayFillerFramesNeeded/2)];

    switch S.GUI.TrainingLevel
        case 1   
            FullVideo = [VideoData repmat(VideoPerturbBasePattern, 1, NumPerturbReps) VideoPerturbBasePattern_remaining_frames GrayBlank];
        case 2
            FullVideo = [VideoData repmat(VideoPerturbBasePattern, 1, NumPerturbReps) VideoPerturbBasePattern_remaining_frames GrayBlank];           
        case 3
            FullVideo = [VideoData repmat(VideoPerturbBasePattern, 1, NumPerturbReps) VideoPerturbBasePattern_remaining_frames GrayBlank];
        case 4
            FullVideo = [VideoData repmat(VideoPerturbBasePattern, 1, NumPerturbReps) VideoPerturbBasePattern_remaining_frames GrayBlank];
        case 5
            FullVideo = [VideoData repmat(VideoPerturbBasePattern, 1, NumPerturbReps) VideoGrayFiller];
    end

    if GrayFillerFramesNeeded < 0
        GrayFillerFramesNeeded = 0;
    end

    if (S.GUI.TrainingLevel == 1 || S.GUI.TrainingLevel == 2 || S.GUI.TrainingLevel == 3 || S.GUI.TrainingLevel == 4)
        FullVideoFrames = S.GUI.NumISIOrigRep * NumInitialBaseFrames + ...
            GratingFrames + ...
            NumPerturbVisRep * NumPerturbBaseFrames + ...
            NumExtraPerturbVisRep * NumPerturbBaseFrames + ...
            NumPerturbVisRep_frame_remainder; % + GratingFrame for the grating between base and variable segments of video and + 1 for final frame
    else
        FullVideoFrames = S.GUI.NumISIOrigRep * NumInitialBaseFrames + ...
            GratingFrames + ...
            NumPerturbVisRep * NumPerturbBaseFrames + ...
            NumExtraPerturbVisRep * NumPerturbBaseFrames + ...
            GrayFillerFramesNeeded; % + GratingFrame for the grating between base and variable segments of video and + 1 for final frame
    end

    FullVideoFrames = length(FullVideo);

    % this can be updated to merge grayfiller and remainder, they're the
    % same thing (are strictly unique though)
    % naive and mid 1 and mid 2: remainder perturb frames are used for fraction
    % of repitition remaining till go cue
    % well: gray filler frames are used till go cue to
    % prevent partial grating during go cue
    if (S.GUI.TrainingLevel == 1 || S.GUI.TrainingLevel == 2 || S.GUI.TrainingLevel == 3 || S.GUI.TrainingLevel == 4)
        VideoStartToGoCueFrames = S.GUI.NumISIOrigRep * NumInitialBaseFrames + ...
            NumPerturbVisRep * NumPerturbBaseFrames + ...
            GratingFrames + ...
            NumPerturbVisRep_frame_remainder;
            % 2*NumISIOrigRep for the repeated grating-gray pattern until go cue, + GratingFrame for the grating between base and variable segments of video and + 1 for final frame    
    else
        VideoStartToGoCueFrames = S.GUI.NumISIOrigRep * NumInitialBaseFrames + ...
            NumPerturbVisRep * NumPerturbBaseFrames + ...
            GratingFrames + ...
            GrayFillerFramesNeeded; % 2*NumISIOrigRep for the repeated grating-gray pattern until go cue, + GratingFrame for the grating between base and variable segments of video and + 1 for final frame            
    end

    VisStimDuration = VideoStartToGoCueFrames / FramesPerSecond; % calculate duration of vis stim based on when go cue state should begin after
                                                                    % start of vis stim state

    % load constructed video into the video object
    BpodSystem.PluginObjects.V.Videos{5} = struct;
    BpodSystem.PluginObjects.V.Videos{5}.nFrames = FullVideoFrames; 
    BpodSystem.PluginObjects.V.Videos{5}.Data = FullVideo;

    
    %% Generate audio stim based on vis stim for this trial

    % build audio stim to match grating/gray pattern
    PrePerturbNoSoundOffset = 1102;
    PrePerturbNoSoundOffset = 0;

    PostPerturbNoSoundOffset = 2205;
    PostPerturbNoSoundOffset = 0;

    GratingNumSamples = GratingDur * SF;     
    GrayNumSamples = GrayDur * SF;  % get duration of gray in number of audio samples for period between audio stim

    NoSoundPrePerturb = zeros(1, GrayNumSamples+PrePerturbNoSoundOffset);

    AudioPrePerturbPattern = [AudioStimSound NoSoundPrePerturb];
    PrePerturbAudioData = [repmat(AudioPrePerturbPattern, 1, S.GUI.NumISIOrigRep) AudioStimSound]; % construct preperturb audio
    

    GrayPerturbDur = length(GrayPerturbVideo) * (1/FramesPerSecond);  % get duration of gray perturb
    GrayPerturbNumSamples = floor(GrayPerturbDur * SF);    % get duration of gray perturb in number of audio samples for period of grating
    NoSoundPerturb = zeros(1, GrayPerturbNumSamples+PostPerturbNoSoundOffset);

    AudioPerturbBasePattern = [NoSoundPerturb AudioStimSound];
    % GrayFillerDur = length(GrayFiller) * (1/FramesPerSecond);  % get duration of gray filler
    % GrayFillerNumSamples = GrayFillerDur * SF;  % get duration of gray filler in number of audio samples
    FullAudioStimData = [PrePerturbAudioData repmat(AudioPerturbBasePattern, 1, NumPerturbReps)];

    switch S.GUI.TrainingLevel
        case 1
            VideoStartToGoCueDur_s = VideoStartToGoCueFrames * (1/FramesPerSecond);
            VideoStartToGoCueDur_NumAudioSamples = SF * VideoStartToGoCueDur_s;
            ShiftedGoCue = [zeros(1, VideoStartToGoCueDur_NumAudioSamples) GoCueSound zeros(1, length(FullAudioStimData) - VideoStartToGoCueDur_NumAudioSamples - length(GoCueSound))];
            FullAudioStimData = FullAudioStimData + ShiftedGoCue;
        case 2
            VideoStartToGoCueDur_s = VideoStartToGoCueFrames * (1/FramesPerSecond);
            VideoStartToGoCueDur_NumAudioSamples = SF * VideoStartToGoCueDur_s;
            ShiftedGoCue = [zeros(1, VideoStartToGoCueDur_NumAudioSamples) GoCueSound zeros(1, length(FullAudioStimData) - VideoStartToGoCueDur_NumAudioSamples - length(GoCueSound))];
            FullAudioStimData = FullAudioStimData + ShiftedGoCue;
        case 3
            VideoStartToGoCueDur_s = VideoStartToGoCueFrames * (1/FramesPerSecond);
            VideoStartToGoCueDur_NumAudioSamples = SF * VideoStartToGoCueDur_s;
            ShiftedGoCue = [zeros(1, VideoStartToGoCueDur_NumAudioSamples) GoCueSound zeros(1, length(FullAudioStimData) - VideoStartToGoCueDur_NumAudioSamples - length(GoCueSound))];
            FullAudioStimData = FullAudioStimData + ShiftedGoCue;
        case 4
            VideoStartToGoCueDur_s = VideoStartToGoCueFrames * (1/FramesPerSecond);
            VideoStartToGoCueDur_NumAudioSamples = SF * VideoStartToGoCueDur_s;
            ShiftedGoCue = [zeros(1, VideoStartToGoCueDur_NumAudioSamples) GoCueSound zeros(1, length(FullAudioStimData) - VideoStartToGoCueDur_NumAudioSamples - length(GoCueSound))];
            FullAudioStimData = FullAudioStimData + ShiftedGoCue;
        case 5
    end

    H.load(5, FullAudioStimData);
    H.load(7, AudioStimSound);

    % Query duration of one monitor refresh interval:
    ifi=Screen('GetFlipInterval', BpodSystem.PluginObjects.V.Window);
    

    %% update trial-specific Audio

    %H.DigitalAttenuation_dB = S.GUI.DigitalAttenuation_dB; % update sound level to param GUI
    if S.GUI.IncorrectSound
        OutputActionArgIncorrect = {'HiFi1', ['P' 2]};
    else
        OutputActionArgIncorrect = {};
    end

    if (S.GUI.InitCueFreq_Hz ~= LastInitCueFrequency) || ...
        (S.GUI.InitCueDuration_s ~= LastInitCueDuration) || ...
        (S.GUI.InitCueVolume_percent ~= LastInitCueVolume)
        InitCueSound = GenerateSineWave(SF, S.GUI.InitCueFreq_Hz, S.GUI.InitCueDuration_s)*S.GUI.InitCueVolume_percent; % Sampling freq (hz), Sine frequency (hz), duration (s)
        InitCueSound = ApplySoundEnvelope(InitCueSound, Envelope);
        H.load(1, InitCueSound);
        LastInitCueFrequency = S.GUI.InitCueFreq_Hz;
        LastInitCueDuration = S.GUI.InitCueDuration_s;
        LastInitCueVolume = S.GUI.InitCueVolume_percent;
    end
    if (S.GUI.GoCueFreq_Hz ~= LastGoCueFrequency) || ...
        (S.GUI.GoCueDuration_s ~= LastGoCueDuration) || ...
        (S.GUI.GoCueVolume_percent ~= LastGoCueVolume)
        GoCueSound = GenerateSineWave(SF, S.GUI.GoCueFreq_Hz, S.GUI.GoCueDuration_s)*S.GUI.GoCueVolume_percent; % Sampling freq (hz), Sine frequency (hz), duration (s)
        GoCueSound = ApplySoundEnvelope(GoCueSound, Envelope);
        H.load(2, GoCueSound);
        LastGoCueFrequency = S.GUI.GoCueFreq_Hz;
        LastGoCueDuration = S.GUI.GoCueDuration_s;
        LastGoCueVolume = S.GUI.GoCueVolume_percent;
    end

    if (S.GUI.PunishSoundDuration_s ~= LastPunishSoundDuration) || ...
        (S.GUI.IncorrectSoundVolume_percent ~= LastIncorrectSoundVolume)
        IncorrectSound = GenerateWhiteNoise(SF, S.GUI.PunishSoundDuration_s, 1, 2)*S.GUI.IncorrectSoundVolume_percent; % white noise punish sound
        IncorrectSound = ApplySoundEnvelope(IncorrectSound, Envelope);
        H.load(3, IncorrectSound);
        LastPunishSoundDuration = S.GUI.PunishSoundDuration_s;
        LastIncorrectSoundVolume = S.GUI.IncorrectSoundVolume_percent;
    end
     

    %% update trial-specific state matrix fields

    % port 1: left (check on bPod console)
    % port 2: middle
    % port 3: right

    switch TrialTypes(currentTrial) % Determine trial-specific state matrix fields
        case 1 % short ISI (defined on line 730) % left side is rewarded
            CorrectLick = 'Port1In';
            CorrectPort = 'Port1';
            IncorrectLick = 'Port3In';
            IncorrectPort = 'Port3';
            StimulusOutput = {'SoftCode', 3};
            RewardPortOut = 'Port1Out'; ValveTime = LeftValveTime; Valve = 'Valve1';
            CorrectWithdrawalEvent = 'Port1Out';
            %VisualGratingDuration = S.GUI.LDuration; % length of time to play visual stimulus when Left TrialType

            ExperimenterTrialInfo.CorrectChoice = 'Left';   % capture variable states as field/value struct for experimenter info
        case 2  % long ISI % right side is rewarded
            CorrectLick = 'Port3In';
            CorrectPort = 'Port3';
            IncorrectLick = 'Port1In';
            IncorrectPort = 'Port1';
            StimulusOutput = {'SoftCode', 4};
            RewardPortOut = 'Port3Out'; ValveTime = RightValveTime; Valve = 'Valve3';
            CorrectWithdrawalEvent = 'Port3Out';
            %VisualGratingDuration = S.GUI.RDuration; % length of time to play visual stimulus when Right TrialType

            ExperimenterTrialInfo.CorrectChoice = 'Right';   % capture variable states as field/value struct for experimenter info
    end

    
    %% trial-specific output actions
    % maybe move this to state-matrix section for consistency
    OutputActionArgInitCue = {'HiFi1', ['P' 0], 'BNCState', 1};
    if S.GUI.VisStimEnable && S.GUI.AudioStimEnable % both vis and audio stim enabled
        OutputActionArgGoCue = {'BNCState', 1};
        OutputActionAudioVisStim = {'SoftCode', 5, 'HiFi1', ['P' 4], 'BNCState', 1};
    elseif S.GUI.VisStimEnable % only vis stim enabled, need regular gocue at state
        OutputActionArgGoCue = {'HiFi1', ['P' 1], 'BNCState', 1};
        OutputActionAudioVisStim = {'SoftCode', 5};
    elseif S.GUI.AudioStimEnable
        OutputActionArgGoCue = {'BNCState', 1};
        OutputActionAudioVisStim = {'HiFi1', ['P' 4], 'BNCState', 1};
    else
        OutputActionArgGoCue = {'HiFi1', ['P' 1], 'BNCState', 1};
        OutputActionAudioVisStim = {};
    end

    OutputActionsPreGoCueDelay = {}; % 
    OutputActionsEarlyChoice = {'SoftCode', 255, 'HiFi1', 'X'}; % stop audio stim, stop vis stim
    OutputActionsPunishSetup = {'SoftCode', 255, 'HiFi1', 'X'};
    visStim = {'SoftCode', 5};
    %audStim = {'HiFi1', ['P', 4], 'BNCState', 1};
    audStim = {'HiFi1', ['P', 6], 'BNCState', 1};


    %% training level specific state matrix values

    switch S.GUI.TrainingLevel

        case 1 % Habituation        
            InitCue_Tup_NextState = 'InitReward'; % change to fn_lic_poiss_3              
            VisualStimulusStateChangeConditions = {'Tup', 'CenterReward'};
            CenterReward_OutputActions = {'Valve2', 1};
            CenterReward_NextSate = 'HabituationExtendWindow';
            GoCue_Tup_NextState = 'RewardNaive';  % naive
            WindowChoice_StateChangeConditions = {};
            OutputActionsWindowChoice = {};
            Reward_Tup_NextState = 'ITI';
            PunishSetup_Tup_NextState = 'PunishNaive'; % Naive
            stimDuration = VisStimDuration;
            ExperimenterTrialInfo.TrainingLevel = 'Habituation';

        case 2 % naive        
            InitCue_Tup_NextState = 'InitWindow'; % change to fn_lic_poiss_3              
            VisualStimulusStateChangeConditions = {'Tup', 'CenterReward'};
            CenterReward_OutputActions = {'Valve2', 1};
            CenterReward_NextSate = 'PreGoCueDelay';
            GoCue_Tup_NextState = 'RewardNaive';  % naive
            WindowChoice_StateChangeConditions = {};
            OutputActionsWindowChoice = {};
            Reward_Tup_NextState = 'ITI';
            PunishSetup_Tup_NextState = 'PunishNaive'; % Naive
            stimDuration = VisStimDuration;
            ExperimenterTrialInfo.TrainingLevel = 'Naive';

        case 3 % Mid 1 Trained
            InitCue_Tup_NextState = 'InitWindow';
            VisualStimulusStateChangeConditions = {'Tup', 'CenterReward'};
            CenterReward_OutputActions = {'Valve2', 1}; % moved video stop code earlier to center reward
            CenterReward_NextSate = 'PreGoCueDelay';
            GoCue_Tup_NextState = 'WindowChoice';  % trained
            WindowChoice_StateChangeConditions = {CorrectLick, 'RewardDelay', 'Condition1', 'RewardDelay', IncorrectLick, 'PunishSetup', 'Condition2', 'PunishSetup', 'Tup', 'DidNotChoose'};
            OutputActionsWindowChoice = {};
            Reward_Tup_NextState = 'ExtraStimDurPostRew_Naive';
            PunishSetup_Tup_NextState = 'Punish'; % trained
            stimDuration = VisStimDuration;
            ExperimenterTrialInfo.TrainingLevel = 'Mid Trained 1';

        case 4 % Mid 2 Trained
            InitCue_Tup_NextState = 'InitWindow';
            VisualStimulusStateChangeConditions = {'Tup', 'VisualStim_AllowedSideLick', 'Port1In', 'EarlyChoice', 'Port3In', 'EarlyChoice'};
            CenterReward_OutputActions = {'Valve2', 1}; % moved video stop code earlier to center reward
            CenterReward_NextSate = 'PreGoCueDelay';
            GoCue_Tup_NextState = 'WindowChoice';  % trained
            WindowChoice_StateChangeConditions = {CorrectLick, 'RewardDelay', 'Condition1', 'RewardDelay', IncorrectLick, 'PunishSetup', 'Condition2', 'PunishSetup', 'Tup', 'DidNotChoose'};
            OutputActionsWindowChoice = {};
            Reward_Tup_NextState = 'ExtraStimDurPostRew_Naive';
            PunishSetup_Tup_NextState = 'Punish'; % trained
            stimDuration = wait_dur;
            ExperimenterTrialInfo.TrainingLevel = 'Mid Trained 2';

        case 5 % well trained
            InitCue_Tup_NextState = 'InitWindow';
            VisualStimulusStateChangeConditions = {'Tup', 'VisualStim_AllowedSideLick', 'Port1In', 'EarlyChoice', 'Port3In', 'EarlyChoice'};
            CenterReward_OutputActions = {'Valve2', 1, 'SoftCode', 255}; % moved video stop code earlier to center reward
            CenterReward_NextSate = 'PreGoCueDelay';
            GoCue_Tup_NextState = 'WindowChoice';  % trained
            OutputActionArgGoCue = {'HiFi1', ['P' 1], 'BNCState', 1};
            WindowChoice_StateChangeConditions = {CorrectLick, 'CorrectLickInterval', 'Condition1', 'CorrectLickInterval', IncorrectLick, 'IncorrectLickInterval', 'Condition2', 'IncorrectLickInterval', 'Tup', 'DidNotChoose'};
            OutputActionsWindowChoice = {'HiFi1', 'X'};
            Reward_Tup_NextState = 'ITI';
            PunishSetup_Tup_NextState = 'Punish'; % trained
            stimDuration = wait_dur;
            ExperimenterTrialInfo.TrainingLevel = 'Well Trained';
    end

   
    %% joystick trial-specific
    BpodSystem.PluginObjects.R.stopUSBStream;   % stop USB streaming to update encoder params
    pause(.05);
    BpodSystem.PluginObjects.R.thresholds = S.GUI.Threshold;    % udate threshold from GUI params
    BpodSystem.PluginObjects.R
    BpodSystem.PluginObjects.R.startUSBStream;  % restart encoder USB streaming

    BpodSystem.Data.TrialData{1, S.GUI.currentTrial}.LeverResetPos = []; % array for lever reset positions
    
    %% resistance level 
    S.GUI.ResistanceLevel = 1;
        S.GUIMeta.ResistanceLevel.Style = 'popupmenu'; % the GUIMeta field is used by the ParameterGUI plugin to customize UI objects.
        S.GUIMeta.ResistanceLevel.String = {'0 mA', '30 mA', '91 mA', '122 mA', '152 mA', '183 mA', '214 mA', '244 mA'};
    
    switch S.GUI.ResistanceLevel
        case 1
            
        case 2

        case 3

        case 4

        case 5

        case 6

        case 7

        case 8

    end


    %% developement state matrix values
    %InitCue_StateChangeConditions = {'Tup', 'InitWindow'};
    OutputActions_InitCue = {'HiFi1', ['P' 0], 'BNCState', 1};

    %InitWindow_StateChangeConditions = {'Tup', 'InitCueAgain', 'Port2In', 'VisStimTrigger1'};
    %InitWindow_StateChangeConditions = {'Tup', 'InitCueAgain', 'Port2In', 'VisualStimulus1'};

    SetLeverBeforePress_StateChangeConditions = {'Tup', 'VisStimTrigger1'}; 
   % SetLeverBeforePress_StateChangeConditions = {'SoftCode1', 'VisStimTrigger1'}; 

    VisStimTrigger1_StateChangeConditions = {'BNC1High', 'VisualStimulus1'};
    %VisStimTrigger1_StateChangeConditions = {'Tup', 'VisualStimulus1'};   


    %WaitForPress1_StateChangeConditions = {'Tup', 'DidNotPress1', 'RotaryEncoder1_1', 'LeverRetract1'};
    %LeverRetract1_StateChangeConditions = {'SoftCode1', 'VisStimTrigger2'};
    %LeverRetract1_StateChangeConditions = {'SoftCode1', 'VisualStimulus2'};

    VisStimTrigger2_StateChangeConditions = {'Tup', 'VisualStimulus2'}; 
    
    WaitForPress2_StateChangeConditions = {'Tup', 'DidNotPress2', 'RotaryEncoder1_1', 'LeverRetract2'};
    %LeverRetract2_StateChangeConditions = {'SoftCode1', 'VisStimTrigger3'};
    %LeverRetract2_StateChangeConditions = {'SoftCode1', 'VisualStimulus3'};

    VisStimTrigger3_StateChangeConditions = {'Tup', 'VisualStimulus3'};

    WaitForPress3_StateChangeConditions = {'Tup', 'DidNotPress3', 'RotaryEncoder1_1', 'LeverRetract3'};
    %LeverRetract3_StateChangeConditions = {'SoftCode1', 'Reward'};

    %CenterReward_StateChangeConditions = {'Tup', 'ITI'};
    %Reward_OutputActions = {'Valve2', 1, 'SoftCode', 9};
    Reward_OutputActions = {'Valve2', 1};
    %CenterReward_OutputActions = {'Valve2', 1, 'SoftCode', 8}; % if using soft code for stepper or other change

    %PostRewardDelay_OutputActions = {'SoftCode', 9};
    PostRewardDelay_OutputActions = {};

    % state flow depending on number of presses per trial
    LeverRetract1_StateChangeConditions = {};
    LeverRetract2_StateChangeConditions = {};
    LeverRetract3_StateChangeConditions = {};

    switch S.GUI.Reps
        case 1
            WaitForPress1_StateChangeConditions = {'Tup', 'DidNotPress1', 'RotaryEncoder1_1', 'Reward1'};
            Reward1_StateChangeConditions = {'Tup', 'PostReward1Delay'};
            LeverRetract1_StateChangeConditions = {'Tup', 'ITI'};
            %LeverRetract1_StateChangeConditions = {'SoftCode1', 'ITI'};
        case 2
            LeverRetract1_StateChangeConditions = {'SoftCode1', 'VisStimTrigger2'};
            LeverRetract2_StateChangeConditions = {'SoftCode1', 'Reward'};
        case 3
            LeverRetract1_StateChangeConditions = {'SoftCode1', 'VisStimTrigger2'};
            LeverRetract2_StateChangeConditions = {'SoftCode1', 'VisStimTrigger3'};
            LeverRetract3_StateChangeConditions = {'SoftCode1', 'Reward'};
    end

    visStim = {'SoftCode', 3};
    
    
    %% training level specific state matrix values

    AuToPress_StateChangeConditions = {};

    switch S.GUI.TrainingLevel
        case 1 % Habituation        
            VisualStimulus1_StateChangeConditions = {'Tup', 'AuToPress'}; % not really important, have as much as you want, eat at Mho's
            AuToPress_StateChangeConditions = {'SoftCode2', 'Reward', 'SoftCode1', 'DidNotPress1'};
            ExperimenterTrialInfo.TrainingLevel = 'Habituation';
        case 2 % naive        
            VisualStimulus1_StateChangeConditions = {'Tup', 'WaitForPress1'};
            ExperimenterTrialInfo.TrainingLevel = 'Naive';
        case 3 % Mid 1 Trained
            VisualStimulus1_StateChangeConditions = {'Tup', 'WaitForPress1'};
            ExperimenterTrialInfo.TrainingLevel = 'Mid Trained 1';
        case 4 % Mid 2 Trained
            VisualStimulus1_StateChangeConditions = {'Tup', 'WaitForPress1'};
            ExperimenterTrialInfo.TrainingLevel = 'Mid Trained 2';
        case 5 % well trained
            VisualStimulus1_StateChangeConditions = {'Tup', 'WaitForPress1'};
            ExperimenterTrialInfo.TrainingLevel = 'Well Trained';
    end

    %%
    ExperimenterTrialInfo.VisStimDuration = VisStimDuration;


    %% After warmup trials, reset wait_dur: with every non early-choice trial, increase it by wait_dur_step

    %[wait_dur] = m_TrialConfig.GetWaitDur(BpodSystem, S, wait_dur, currentTrial, LastNumEasyWarmupTrials, VisStimDuration);
    wait_dur = 0;

    ExperimenterTrialInfo.WaitDuration = wait_dur;


    %% add console print for experimenter trial information

    strExperimenterTrialInfo = formattedDisplayText(ExperimenterTrialInfo,'UseTrueFalseForLogical',true);
    disp(strExperimenterTrialInfo);


    %% construct state matrix

    sma = NewStateMatrix(); % Assemble state matrix
    % needs more conditions here when adding difficulty levels
    sma = SetCondition(sma, 1, CorrectPort, 1); % Condition 1: Correct Port is high (licking)
    sma = SetCondition(sma, 2, IncorrectPort, 1); % Condition 2: Incorrect Port is high (licking)

    % testing behavior port4in port4out for use as sync signal from camera
    sma = SetCondition(sma, 3, 'Port4', 1); % Condition 3: Sync signal high
    sma = SetCondition(sma, 4, 'Port4', 0); % Condition 4: Sync signal low
    sma = SetCondition(sma, 5, 'Port2', 1); % Condition 5: center port is high (licking)

    sma = AddState(sma, 'Name', 'Start', ...
        'Timer', 0,...
        'StateChangeConditions', {'Tup', 'SetLeverBeforePress'},...
        'OutputActions', {'HiFi1','*', 'RotaryEncoder1', ['E#' 0]}); % Code to push newly uploaded waves to front (playback) buffers
    %'OutputActions', {'HiFi1','*', 'Stepper1', ['i' TrialHoldingCurrent 0]}); % Code to push newly uploaded waves to front (playback) buffers
    
    % sma = AddState(sma, 'Name', 'InitCue', ...
    %     'Timer', S.GUI.InitCueDuration_s,...
    %     'StateChangeConditions', InitCue_StateChangeConditions,...         
    %     'OutputActions', OutputActions_InitCue);
    % 
    % sma = AddState(sma, 'Name', 'InitWindow', ...
    %     'Timer', S.GUI.InitWindowTimeout_s,...
    %     'StateChangeConditions', InitWindow_StateChangeConditions,...         
    %     'OutputActions', {});    
    % 
    % sma = AddState(sma, 'Name', 'InitCueAgain', ...
    %     'Timer', 0,...
    %     'StateChangeConditions', {'Tup', 'InitCue'},...         
    %     'OutputActions', {});

%% set lever at start pos if it isn't already

    sma = AddState(sma, 'Name', 'SetLeverBeforePress', ...
        'Timer', 0,...
        'StateChangeConditions', SetLeverBeforePress_StateChangeConditions,...
        'OutputActions',  {});

    % sma = AddState(sma, 'Name', 'SetLeverBeforePress', ...
    %     'Timer', 0,...
    %     'StateChangeConditions', SetLeverBeforePress_StateChangeConditions,...
    %     'OutputActions',  {'SoftCode', 7});

    % sma = AddState(sma, 'Name', 'SetLeverBeforePress', ...
    %     'Timer', 0,...
    %     'StateChangeConditions', {'Tup', 'VisStimTrigger1'},...
    %     'OutputActions',  {});

%% rep 1
    
    sma = AddState(sma, 'Name', 'VisStimTrigger1', ...
        'Timer', 0,...
        'StateChangeConditions', VisStimTrigger1_StateChangeConditions,...
        'OutputActions', visStim);

    sma = AddState(sma, 'Name', 'VisualStimulus1', ...
        'Timer', S.GUI.GratingDur_s,...
        'StateChangeConditions', VisualStimulus1_StateChangeConditions,...
        'OutputActions', audStim);

    sma = AddState(sma, 'Name', 'AuToPress', ...
        'Timer', 0,...
        'StateChangeConditions', AuToPress_StateChangeConditions,...
        'OutputActions', {'RotaryEncoder1', ['E'], 'SoftCode', 9});

sma = AddState(sma, 'Name', 'WaitForPress1', ...
        'Timer', S.GUI.PressWindow_s,...
        'StateChangeConditions', WaitForPress1_StateChangeConditions,...
        'OutputActions', {'Stepper1', ['i' 0 0], 'SoftCode', 12,'RotaryEncoder1', ['E'], 'PWM1', 255}); % ['i' 0 0] turns off the stepper holding current. 

    % sma = AddState(sma, 'Name', 'WaitForPress1', ...
    %     'Timer', S.GUI.PressWindow_s,...
    %     'StateChangeConditions', WaitForPress1_StateChangeConditions,...
    %     'OutputActions', {'SoftCode', 8,'RotaryEncoder1', ['E'], 'PWM1', 255}); % ['i' 0 0] turns off the stepper holding current. 
                                                                                       % 'E' enables the rotary encoder thresholds
                                                                                       % ['#' 0] sends byte 0x0 to the rotary encoder module for 
                                                                                       %         a trial start timestamp on its clock 
                                                                                       % 'PWM1', 255 sets Port1 LED to max brightness    
        % 'OutputActions', {'Stepper1', ['i' 0 0], 'RotaryEncoder1', ['E#' 0], 'PWM1', 255}); % ['i' 0 0] turns off the stepper holding current. 
                                                                                       % 'E' enables the rotary encoder thresholds
                                                                                       % ['#' 0] sends byte 0x0 to the rotary encoder module for 
                                                                                       %         a trial start timestamp on its clock 
                                                                                       % 'PWM1', 255 sets Port1 LED to max brightness    


    % can add if different stepper behavior is needed using another soft
    % code
    % sma = AddState(sma, 'Name', 'LeverStall', ...
    %     'Timer', 2,...
    %     'StateChangeConditions', {'Tup', 'LeverRetract1'},... % When the PC is done resetting the lever, it sends soft code 1 to the state machine
    %     'OutputActions', {'SoftCode', 12}); % On entering the LeverRetract state, send soft code 1 to the PC. The soft code handler will then start resetting the lever.
    sma = AddState(sma, 'Name', 'Reward1', ...
        'Timer', CenterValveTime,...
        'StateChangeConditions', Reward1_StateChangeConditions,...
        'OutputActions', Reward_OutputActions);

    sma = AddState(sma, 'Name', 'PostReward1Delay', ...
        'Timer', S.GUI.PostRewardDelay_s,...
        'StateChangeConditions', {'Tup', 'LeverRetract1'},...
        'OutputActions', PostRewardDelay_OutputActions);    
    
    sma = AddState(sma, 'Name', 'LeverRetract1', ...
        'Timer', 0,...
        'StateChangeConditions', LeverRetract1_StateChangeConditions,... % When the PC is done resetting the lever, it sends soft code 1 to the state machine
        'OutputActions', {'SoftCode', 13}); % On entering the LeverRetract state, send soft code 1 to the PC. The soft code handler will then start resetting the lever.

    % sma = AddState(sma, 'Name', 'LeverRetract1', ...
    %     'Timer', 0,...
    %     'StateChangeConditions', LeverRetract1_StateChangeConditions,... % When the PC is done resetting the lever, it sends soft code 1 to the state machine
    %     'OutputActions', {'SoftCode', 7}); % On entering the LeverRetract state, send soft code 1 to the PC. The soft code handler will then start resetting the lever.
   
%% rep 2

    sma = AddState(sma, 'Name', 'VisStimTrigger2', ...
        'Timer', 0,...
        'StateChangeConditions', VisStimTrigger2_StateChangeConditions,...
        'OutputActions', visStim);

    sma = AddState(sma, 'Name', 'VisualStimulus2', ...
        'Timer', S.GUI.GratingDur_s,...
        'StateChangeConditions', {'Tup', 'WaitForPress2'},...
        'OutputActions', {});

    sma = AddState(sma, 'Name', 'WaitForPress2', ...
        'Timer', S.GUI.PressWindow_s,...
        'StateChangeConditions', WaitForPress2_StateChangeConditions,...
        'OutputActions', {'RotaryEncoder1', 'E', 'PWM1', 255}); % Port1 LED turns on to indicate that the lever is ready to press
%        'OutputActions', {'Stepper1', ['i' 0 0], 'RotaryEncoder1', 'E', 'PWM1', 255}); % Port1 LED turns on to indicate that the lever is ready to press
    
    sma = AddState(sma, 'Name', 'LeverRetract2', ...
        'Timer', 0,...
        'StateChangeConditions', LeverRetract2_StateChangeConditions,...
        'OutputActions', {'SoftCode', 7});
   
%% rep 3
    
    sma = AddState(sma, 'Name', 'VisStimTrigger3', ...
        'Timer', 0,...
        'StateChangeConditions', VisStimTrigger3_StateChangeConditions,...
        'OutputActions', visStim);

    sma = AddState(sma, 'Name', 'VisualStimulus3', ...
        'Timer', S.GUI.GratingDur_s,...
        'StateChangeConditions', {'Tup', 'WaitForPress3'},...
        'OutputActions', {});

    sma = AddState(sma, 'Name', 'WaitForPress3', ...
        'Timer', S.GUI.PressWindow_s,...
        'StateChangeConditions', WaitForPress3_StateChangeConditions,...
        'OutputActions', {'RotaryEncoder1', 'E', 'PWM1', 255}); % Port1 LED turns on to indicate that the lever is ready to press
    %'OutputActions', {'Stepper1', ['i' 0 0], 'RotaryEncoder1', 'E', 'PWM1', 255}); % Port1 LED turns on to indicate that the lever is ready to press
    
    sma = AddState(sma, 'Name', 'LeverRetract3', ...
        'Timer', 0,...
        'StateChangeConditions', LeverRetract3_StateChangeConditions,...
        'OutputActions', {'SoftCode', 7});    

%% reps complete
    % sma = AddState(sma, 'Name', 'Reward', ...
    %     'Timer', CenterValveTime,...
    %     'StateChangeConditions', CenterReward_StateChangeConditions,...
    %     'OutputActions', CenterReward_OutputActions); 

    sma = AddState(sma, 'Name', 'DidNotPress1', ...
        'Timer', 0,...
        'StateChangeConditions', {'Tup', 'ITI'},...
        'OutputActions', {'SoftCode', 13, 'HiFi1', ['P' 2]});

    % sma = AddState(sma, 'Name', 'DidNotPress1', ...
    %     'Timer', 0,...
    %     'StateChangeConditions', {'Tup', 'ITI'},...
    %     'OutputActions', {'SoftCode', 7, 'HiFi1', ['P' 2]});

    sma = AddState(sma, 'Name', 'DidNotPress2', ...
        'Timer', 0,...
        'StateChangeConditions', {'Tup', 'ITI'},...
        'OutputActions', {});

    sma = AddState(sma, 'Name', 'DidNotPress3', ...
        'Timer', 0,...
        'StateChangeConditions', {'Tup', 'ITI'},...
        'OutputActions', {});    

    sma = AddState(sma, 'Name', 'ITI', ...
        'Timer', ITI,...
        'StateChangeConditions', {'Tup', '>exit'},...
        'OutputActions', {}); 

    SendStateMachine(sma); % Send the state matrix to the Bpod device        
    RawEvents = RunStateMachine; % Run the trial and return events
   
    if ~isempty(fieldnames(RawEvents)) % If trial data was returned (i.e. if not final trial, interrupted by user)
        BpodSystem.Data = AddTrialEvents(BpodSystem.Data,RawEvents); % Computes trial events from raw data
        BpodSystem.Data.TrialSettings(currentTrial) = S; % Adds the settings used for the current trial to the Data struct (to be saved after the trial ends)
        BpodSystem.Data.TrialTypes(currentTrial) = TrialTypes(currentTrial); % Adds the trial type of the current trial to data
        m_Plotter.UpdateOutcomePlot(BpodSystem, TrialTypes, 1);
        if useStateTiming
            StateTiming();
        end

        BpodSystem.Data.EncoderData{currentTrial} = BpodSystem.PluginObjects.R.readUSBStream(); % Get rotary encoder data captured since last call to R.readUSBStream()
        % Align this trial's rotary encoder timestamps to state machine trial-start (timestamp of '#' command sent from state machine to encoder module in 'TrialStart' state)
        BpodSystem.Data.EncoderData{currentTrial}.Times = BpodSystem.Data.EncoderData{currentTrial}.Times - BpodSystem.Data.EncoderData{currentTrial}.EventTimestamps(1); % Align timestamps to state machine's trial time 0
        BpodSystem.Data.EncoderData{currentTrial}.EventTimestamps = BpodSystem.Data.EncoderData{currentTrial}.EventTimestamps - BpodSystem.Data.EncoderData{currentTrial}.EventTimestamps(1); % Align event timestamps to state machine's trial time 0
        
        % Update rotary encoder plot
        % might reduce this section to pass
        % BpodSystem.Data.RawEvents.Trial{1, currentTrial}.States, and
        % access them in plot function
        TrialDuration = BpodSystem.Data.TrialEndTimestamp(currentTrial)-BpodSystem.Data.TrialStartTimestamp(currentTrial);

        % extrapolate start and end position and time values for missing data -> impute
        if ~isempty(BpodSystem.Data.EncoderData{currentTrial}.Times)
            % if missing position values between start of trial and first
            % encoder movement, extrapolate from first recorded enc
            % position
            if BpodSystem.Data.EncoderData{currentTrial}.Times(1) > 0
                BpodSystem.Data.EncoderData{currentTrial}.Times = [0.0 BpodSystem.Data.EncoderData{currentTrial}.Times];
                BpodSystem.Data.EncoderData{currentTrial}.Positions = [BpodSystem.Data.EncoderData{currentTrial}.Positions(1) BpodSystem.Data.EncoderData{currentTrial}.Positions];
                BpodSystem.Data.EncoderData{currentTrial}.nPositions = BpodSystem.Data.EncoderData{currentTrial}.nPositions + 1;                
            end
            % if missing position values after last encoder movement,
            % extrapolate from last recorded enc position
            if BpodSystem.Data.EncoderData{currentTrial}.Times(end) < TrialDuration
                BpodSystem.Data.EncoderData{currentTrial}.Times = [BpodSystem.Data.EncoderData{currentTrial}.Times TrialDuration];
                BpodSystem.Data.EncoderData{currentTrial}.Positions = [BpodSystem.Data.EncoderData{currentTrial}.Positions BpodSystem.Data.EncoderData{currentTrial}.Positions(end)];
                BpodSystem.Data.EncoderData{currentTrial}.nPositions = BpodSystem.Data.EncoderData{currentTrial}.nPositions + 1;                
            end
        end  

        SetLeverBeforePressTimes = BpodSystem.Data.RawEvents.Trial{1, currentTrial}.States.SetLeverBeforePress;
        VisStimTrigger1Times = BpodSystem.Data.RawEvents.Trial{1, currentTrial}.States.VisStimTrigger1;
        VisualStimulus1Times = BpodSystem.Data.RawEvents.Trial{1, currentTrial}.States.VisualStimulus1;
        WaitForPress1Times = BpodSystem.Data.RawEvents.Trial{1, currentTrial}.States.WaitForPress1;
        LeverRetract1Times = BpodSystem.Data.RawEvents.Trial{1, currentTrial}.States.LeverRetract1;
        Reward1Times = BpodSystem.Data.RawEvents.Trial{1, currentTrial}.States.Reward1;
        DidNotPress1Times = BpodSystem.Data.RawEvents.Trial{1, currentTrial}.States.DidNotPress1;
        ITITimes = BpodSystem.Data.RawEvents.Trial{1, currentTrial}.States.ITI;

        LeverResetPos = BpodSystem.Data.TrialData{1, currentTrial}.LeverResetPos;


        LastTrialEncoderPlot(BpodSystem.GUIHandles.EncoderAxes, 'update', S.GUI.Threshold, BpodSystem.Data.EncoderData{currentTrial},...
            TrialDuration, ...
            SetLeverBeforePressTimes, ...
            VisStimTrigger1Times, ...
            VisualStimulus1Times, ...
            WaitForPress1Times, ...
            LeverRetract1Times, ...
            Reward1Times, ...
            DidNotPress1Times, ...
            ITITimes, ...
            LeverResetPos);

        SaveBpodSessionData; % Saves the field BpodSystem.Data to the current data file
    end
    HandlePauseCondition; % Checks to see if the protocol is paused. If so, waits until user resumes.
    if BpodSystem.Status.BeingUsed == 0 % If protocol was stopped, exit the loop
        BpodSystem.PluginObjects.V = [];
        % BpodSystem.setStatusLED(1); % enable Bpod status LEDs after session
        BpodSystem.PluginObjects.R.stopUSBStream; % Stop streaming position data
        BpodSystem.PluginObjects.R.sendThresholdEvents = 'off'; % Stop sending threshold events to state machine
        BpodSystem.PluginObjects.S.holdRMScurrent = 0; % Release the lever
        BpodSystem.PluginObjects.R = [];
        BpodSystem.PluginObjects.S = [];        
        M = [];
        return
    end

    %% Take care of WarmupTrialsCounter

    if WarmupTrialsCounter > 0
	    WarmupTrialsCounter = WarmupTrialsCounter - 1;
    end


end

BpodSystem.PluginObjects.V = [];
BpodSystem.setStatusLED(1); % enable Bpod status LEDs after session
BpodSystem.PluginObjects.R.stopUSBStream; % Stop streaming position data
BpodSystem.PluginObjects.R.sendThresholdEvents = 'off'; % Stop sending threshold events to state machine
BpodSystem.PluginObjects.S.holdRMScurrent = 0; % Release the lever
BpodSystem.PluginObjects.R = [];
BpodSystem.PluginObjects.S = [];
M = [];
end

% generate full envelope for sound given the sound and front part of
% envelope, return enveloped sound
function [SoundWithEnvelope] = ApplySoundEnvelope(Sound, Envelope)
    BackOfTheEnvelope = fliplr(Envelope);   % flipe front envelope to get back envelope
    IdxsBetweenTheEnvelope = length(Sound) - 2 * length(Envelope); % indices between front and back of envelope
    FullEnvelope = [Envelope ones(1, IdxsBetweenTheEnvelope) BackOfTheEnvelope];  % full envelope
    SoundWithEnvelope = Sound .* FullEnvelope;    % apply envelope element-wise
end

function SetMotorPos = ConvertMaestroPos(MaestroPosition)
    m = 0.002;
    b = -3;
    SetMotorPos = MaestroPosition * m + b;
end

